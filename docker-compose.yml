services:
  postgres:
    image: postgres:15-alpine
    container_name: kasashka_postgres
    environment:
      POSTGRES_USER: kasashka
      POSTGRES_PASSWORD: kasashka_password
      POSTGRES_DB: kasashka_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./db/init:/docker-entrypoint-initdb.d
      - ./db/seeds:/db/seeds
      - ./db/migrations:/db/migrations:ro
    networks:
      - kasashka_net

  redis:
    image: redis:7-alpine
    container_name: kasashka_redis
    command: ["redis-server", "--appendonly", "yes"]
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - kasashka_net

  minio:
    image: minio/minio:latest
    container_name: kasashka_minio
    command: server /data --console-address ":9001"
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadminpassword
    ports:
      - "9000:9000"
      - "9001:9001"
    volumes:
      - minio_data:/data
    networks:
      - kasashka_net

  # Создание bucket при первом старте (идемпотентно)
  minio_init:
    image: minio/mc:latest
    container_name: kasashka_minio_init
    depends_on:
      - minio
    entrypoint:
      - /bin/sh
      - -c
      - |
        set -e
        echo "Waiting for MinIO..."
        until mc alias set local http://minio:9000 "$$MINIO_ROOT_USER" "$$MINIO_ROOT_PASSWORD" >/dev/null 2>&1; do
          sleep 1
        done
        echo "Ensuring bucket $$MINIO_BUCKET exists..."
        mc mb -p "local/$$MINIO_BUCKET" >/dev/null 2>&1 || true
        # bucket оставляем приватным — отдачу делаем через API-прокси приложения
        echo "MinIO init done."
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadminpassword
      MINIO_BUCKET: media
    networks:
      - kasashka_net

  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: kasashka_app
    working_dir: /usr/src/app
    command: sh -c "chmod +x node_modules/.bin/next && npm run dev"
    volumes:
      - ./:/usr/src/app
      - /usr/src/app/node_modules
    environment:
      NODE_ENV: development
      # строка подключения к Postgres из контейнера app
      DATABASE_URL: postgresql://kasashka:kasashka_password@postgres:5432/kasashka_db
      # строка подключения к Redis из контейнера app
      REDIS_URL: redis://redis:6379
      NEXT_PUBLIC_API_BASE_URL: http://localhost
      # MinIO (S3-compatible) для хранения изображений
      MINIO_ENDPOINT: minio
      MINIO_PORT: "9000"
      MINIO_USE_SSL: "false"
      MINIO_ACCESS_KEY: minioadmin
      MINIO_SECRET_KEY: minioadminpassword
      MINIO_BUCKET: media
    depends_on:
      - postgres
      - redis
      - minio
      - minio_init
    ports:
      - "3000:3000"
    networks:
      - kasashka_net

  nginx:
    image: nginx:alpine
    container_name: kasashka_nginx
    depends_on:
      - app
    ports:
      - "80:80"
    volumes:
      - ./infra/nginx/nginx.conf:/etc/nginx/nginx.conf:ro
    networks:
      - kasashka_net

  # Dozzle — веб-интерфейс для просмотра логов Docker контейнеров
  dozzle:
    image: amir20/dozzle:latest
    container_name: kasashka_dozzle
    ports:
      - "9999:8080"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - kasashka_net
    restart: unless-stopped

  # LLM inference server (LLaMA 3.x Instruct via Ollama)
  # App will call it over http://ollama:11434
  ollama:
    image: ollama/ollama:latest
    container_name: kasashka_ollama
    ports:
      - "11434:11434"
    volumes:
      - ollama_data:/root/.ollama
    networks:
      - kasashka_net
    restart: unless-stopped

  # Опционально: авто-загрузка модели при старте (нужен интернет)
  # Укажите OLLAMA_MODEL в .env/.env.local, например: llama3.1:8b-instruct
  ollama_init:
    image: ollama/ollama:latest
    container_name: kasashka_ollama_init
    depends_on:
      - ollama
    entrypoint:
      - /bin/sh
      - -c
      - |
        set -e
        # ВАЖНО: используем $$ чтобы docker compose не пытался интерполировать переменные в этом блоке
        # По умолчанию берём более лёгкую модель (подходит для машин с 8GB RAM и меньше)
        OLLAMA_MODEL="$${OLLAMA_MODEL:-llama3.2:3b}"
        export OLLAMA_HOST="http://ollama:11434"
        echo "Waiting for Ollama..."
        # Не используем wget/curl (их может не быть в образе). Проверяем доступность через ollama CLI.
        until ollama list >/dev/null 2>&1; do
          sleep 1
        done
        echo "Pulling model: $${OLLAMA_MODEL}"
        if ! ollama pull "$${OLLAMA_MODEL}"; then
          echo "ERROR: Failed to pull model: $${OLLAMA_MODEL}"
          exit 1
        fi
        echo "Ollama init done."
    environment:
      OLLAMA_MODEL: ${OLLAMA_MODEL:-llama3.2:3b}
    volumes:
      - ollama_data:/root/.ollama
    networks:
      - kasashka_net

  # База данных для Zabbix
  zabbix_db:
    image: postgres:15-alpine
    container_name: kasashka_zabbix_db
    environment:
      POSTGRES_USER: zabbix
      POSTGRES_PASSWORD: zabbix_password
      POSTGRES_DB: zabbix
    ports:
      - "5433:5432"
    volumes:
      - zabbix_db_data:/var/lib/postgresql/data
    networks:
      - kasashka_net
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U zabbix"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Zabbix Server
  zabbix_server:
    image: zabbix/zabbix-server-pgsql:alpine-7.0-latest
    container_name: kasashka_zabbix_server
    depends_on:
      zabbix_db:
        condition: service_healthy
    # docker compose по умолчанию читает только .env, а не .env.local
    # поэтому явно подключаем .env.local (где у тебя лежит TELEGRAM_BOT_TOKEN)
    env_file:
      - .env.local
    environment:
      DB_SERVER_HOST: zabbix_db
      DB_SERVER_PORT: 5432
      POSTGRES_USER: zabbix
      POSTGRES_PASSWORD: zabbix_password
      POSTGRES_DB: zabbix
      # Telegram переменные берём из env_file (.env.local), чтобы не затирать их пустыми значениями
    ports:
      - "10051:10051"
    volumes:
      - zabbix_server_data:/var/lib/zabbix
      - ./infra/zabbix/alertscripts:/usr/lib/zabbix/alertscripts:ro
      - ./infra/zabbix/externalscripts:/usr/lib/zabbix/externalscripts:ro
    networks:
      - kasashka_net
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "nc -z localhost 10051 || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

  # Zabbix Web Interface
  zabbix_web:
    image: zabbix/zabbix-web-apache-pgsql:alpine-7.0-latest
    container_name: kasashka_zabbix_web
    depends_on:
      - zabbix_db
      - zabbix_server
    environment:
      ZBX_SERVER_HOST: zabbix_server
      DB_SERVER_HOST: zabbix_db
      DB_SERVER_PORT: 5432
      POSTGRES_USER: zabbix
      POSTGRES_PASSWORD: zabbix_password
      POSTGRES_DB: zabbix
      PHP_TZ: Europe/Moscow
    ports:
      - "8080:8080"
    networks:
      - kasashka_net
    restart: unless-stopped

  # Zabbix Agent для мониторинга контейнеров
  zabbix_agent:
    # Важно: для шаблона "Docker by Zabbix agent 2" нужен именно agent2
    image: zabbix/zabbix-agent2:alpine-7.0-latest
    container_name: kasashka_zabbix_agent
    depends_on:
      zabbix_server:
        condition: service_healthy
    environment:
      ZBX_HOSTNAME: docker-host
      ZBX_SERVER_HOST: zabbix_server
      ZBX_SERVER_PORT: 10051
      # Agent2: активные проверки (опционально, но помогает с авто-регистрацией/связью)
      ZBX_SERVER_ACTIVE: zabbix_server
      ZBX_TIMEOUT: 30
    volumes:
      # Docker socket для docker-плагина Agent2 (обязательно)
      - /var/run/docker.sock:/var/run/docker.sock
      # Конфиг docker-плагина Agent2 (без правки основного конфига entrypoint'ом)
      - ./infra/zabbix/zabbix_agent2.d/plugins.d/docker.conf:/etc/zabbix/zabbix_agent2.d/plugins.d/docker.conf:ro
    # На некоторых системах docker.sock доступен не всем пользователям — проще читать его от root
    user: "0:0"
    networks:
      - kasashka_net
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
  minio_data:
  zabbix_db_data:
  zabbix_server_data:
  ollama_data:

networks:
  kasashka_net:
    driver: bridge
